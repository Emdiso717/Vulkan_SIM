#version 450

struct Particle {
	vec4 pos;
	vec4 vel;
	vec4 uv;
	vec4 normal;
};

layout(std430, binding = 0) buffer ParticleIn {
	Particle particleIn[ ];
};

layout(std430, binding = 1) buffer ParticleOut {
	Particle particleOut[ ];
};

// todo: use shared memory to speed up calculation

layout (local_size_x = 10) in;

layout (binding = 2) uniform UBO 
{
	float deltaT;
	float particleMass;
	float springStiffness;
	float damping;
	float restDistH;
	float restDistV;
	float restDistD;
	float sphereRadius;
	vec4 spherePos;
	vec4 gravity;
	ivec2 particleCount;
} params;

struct ElementInfo {
  int elemId;
  ivec2 pid;
  float restLength;
};

layout(std430, binding = 3) buffer LambdaBuffer {
  float _lambda[];
};

layout(std430, binding = 4) buffer ElementInfoBuffer {
  ElementInfo elementInfo[];
};

layout(std430, binding = 5) buffer ElemParallelSlotsBuffer {
  int elemParallelSlots[];
};

layout (push_constant) uniform PushConsts {
	uint computeStage;  // 0: begin solve, 1: constraint solving, 2: end solve
	uint parallelSetStartIndex;
} pushConsts;

vec3 springForce(vec3 p0, vec3 p1, float restDist) 
{
	vec3 dist = p0 - p1;
	return normalize(dist) * params.springStiffness * (length(dist) - restDist);
}

void main() 
{
	uvec3 id = gl_GlobalInvocationID; 

	uint index = id.x;
	uint numParticles = params.particleCount.x * params.particleCount.y;


	// ========== DEBUG: Verify buffers are received ==========
	// Test: Modify lambda[0] and elemParallelSlots[0] to verify buffer is accessible
	// Only let the first thread (index == 0) modify to avoid race conditions
	
	if(pushConsts.computeStage == 0) {
		if (index >= numParticles) 
			return;
		// BEGIN SOLVE: Predict positions and reset lambdas
		if (index < particleIn.length()) {
			// Save old position to vel field (for velocity calculation in endSolve)
			particleOut[index].vel = particleIn[index].pos;
			
			// Predict displacement: dx = vel * dt + 0.5 * gravity * dtÂ²
			vec3 dx = particleIn[index].vel.xyz * params.deltaT;
			dx += 0.5 * params.gravity.xyz * params.deltaT * params.deltaT;
			
			// Update predicted position
			particleOut[index].pos = particleIn[index].pos + vec4(dx, 0.0);
			
			// // Copy UV and normal (preserve these values)
			particleOut[index].uv = particleIn[index].uv;
			particleOut[index].normal = particleIn[index].normal;
			particleIn[index].pos = particleOut[index].pos;
			particleIn[index].vel = particleOut[index].vel;
			// particleOut[index].vel = particleIn[index].vel;
			// particleOut[index].pos = particleIn[index].pos;
		}
		if (index < _lambda.length()) {
			_lambda[index] = 0.0;
		}
	}
	else if(pushConsts.computeStage == 1) {
		// CONSTRAINT SOLVE: XPBD iterations
		 int st = elemParallelSlots[pushConsts.parallelSetStartIndex];
  		 int ed = elemParallelSlots[pushConsts.parallelSetStartIndex + 1];
         if (index + st >= ed)
            return;
		const int elemId = int(index) + st;
  		const ElementInfo elemInfo = elementInfo[elemId];

 		const float invDt = float(1) / params.deltaT;
  		const float invDt2 = invDt * invDt;

  		mat2x3 localV;
  		vec2 localMassInv;
        localV[0] = particleIn[elemInfo.pid[0]].pos.xyz;
        localV[1] = particleIn[elemInfo.pid[1]].pos.xyz;
        localMassInv[0] = 1.0 / params.particleMass;
        localMassInv[1] = 1.0 / params.particleMass;
        float local_alpha = float(1.0) / (params.springStiffness * invDt2);
        float DLambda = -(length(localV[1] - localV[0]) - elemInfo.restLength) /
                  (localMassInv[0] + localMassInv[1] + local_alpha);
        _lambda[elemId] += DLambda;
        particleIn[elemInfo.pid[0]].pos.xyz = particleIn[elemInfo.pid[0]].pos.xyz +
        float(1.0) * localMassInv[0] * DLambda * normalize(localV[0] - localV[1]) * params.deltaT;
        particleIn[elemInfo.pid[1]].pos.xyz = particleIn[elemInfo.pid[1]].pos.xyz +
        float(1.0) * localMassInv[1] * DLambda * normalize(localV[1] - localV[0]) * params.deltaT;
	}
	else if(pushConsts.computeStage == 2) {
		if (index >= numParticles) 
			return;
		// END SOLVE: Update velocities based on position changes
		if (index < particleIn.length()) {
			// Old position was saved in vel field during beginSolve
			vec3 oldPos = particleIn[index].vel.xyz;
			vec3 newPos = particleIn[index].pos.xyz;
			
			// Update velocity: v = (newPos - oldPos) / dt
			vec3 newVel = (newPos - oldPos) / params.deltaT;
			
			particleOut[index].vel = vec4(newVel, 0.0);
			particleOut[index].pos = particleIn[index].pos;
			particleOut[index].uv = particleIn[index].uv;
			particleOut[index].normal = particleIn[index].normal;
		}
		vec3 sphereDist = particleOut[index].pos.xyz - params.spherePos.xyz;
		if (length(sphereDist) < params.sphereRadius + 0.01) {
		// If the particle is inside the sphere, push it to the outer radius
		particleOut[index].pos.xyz = params.spherePos.xyz + normalize(sphereDist) * (params.sphereRadius + 0.01);		
		// Cancel out velocity
		particleOut[index].vel = vec4(0.0);
	}
	}

}